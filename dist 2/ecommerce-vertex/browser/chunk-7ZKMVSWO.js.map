{
  "version": 3,
  "sources": ["src/app/core/services/auth.service.ts"],
  "sourcesContent": ["import { inject, Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport {\n  Auth,\n  signInWithEmailAndPassword,\n  signOut,\n  updatePassword,\n  reauthenticateWithCredential,\n  EmailAuthProvider,\n  User\n} from '@angular/fire/auth';\nimport { from, Observable, of } from 'rxjs';\nimport { switchMap, map } from 'rxjs/operators';\nimport { user } from '@angular/fire/auth';\nimport { SweetAlertService } from './sweet-alert.service';\n\n@Injectable({ providedIn: 'root' })\nexport class AuthService {\n  private auth = inject(Auth);\n  private router = inject(Router);\n  private sweetAlertService = inject(SweetAlertService);\n\n  public currentUser$ = user(this.auth);\n\n  public isAdmin$: Observable<boolean> = this.currentUser$.pipe(\n    switchMap(user => {\n      if (!user) {\n        return of(false);\n      }\n      return from(user.getIdTokenResult());\n    }),\n    map(tokenResult => {\n      if (tokenResult && typeof tokenResult === 'object') {\n        return tokenResult.claims['admin'] === true;\n      }\n      return false;\n    })\n  );\n\n  constructor() { }\n\n  login(email: string, password: string) {\n    return from(signInWithEmailAndPassword(this.auth, email, password));\n  }\n\n  async logout(options?: { title?: string; text?: string }): Promise<void> {\n    try {\n      await signOut(this.auth);\n\n      const title = options?.title || 'Sesión Cerrada';\n      const text = options?.text || 'Has sido redirigido a la página de inicio de sesión.';\n\n      this.sweetAlertService.success(title, text);\n      this.router.navigate(['/admin/login']);\n\n    } catch (err) {\n      console.error('Error al cerrar sesión:', err);\n      this.sweetAlertService.error('Error', 'No se pudo cerrar la sesión. Por favor, inténtalo de nuevo.');\n      throw err;\n    }\n  }\n\n  isAuthenticated(): Observable<boolean> {\n    return this.currentUser$.pipe(\n      map(user => !!user)\n    );\n  }\n\n  async changePassword(currentPassword: string, newPassword: string): Promise<boolean> {\n    const user: User | null = this.auth.currentUser;\n\n    if (!user || !user.email) {\n      throw new Error('No hay usuario autenticado o el email no está disponible.');\n    }\n\n    try {\n      const credential = EmailAuthProvider.credential(user.email, currentPassword);\n      await reauthenticateWithCredential(user, credential);\n      await updatePassword(user, newPassword);\n      console.log('Contraseña actualizada exitosamente en Firebase.');\n      return true;\n\n    } catch (error) {\n      console.error('Error en el proceso de cambio de contraseña:', error);\n      throw error;\n    }\n  }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBM,IAAO,cAAP,MAAO,aAAW;EACd,OAAO,OAAO,IAAI;EAClB,SAAS,OAAO,MAAM;EACtB,oBAAoB,OAAO,iBAAiB;EAE7C,eAAe,KAAK,KAAK,IAAI;EAE7B,WAAgC,KAAK,aAAa,KACvD,UAAU,CAAAA,UAAO;AACf,QAAI,CAACA,OAAM;AACT,aAAO,GAAG,KAAK;IACjB;AACA,WAAO,KAAKA,MAAK,iBAAgB,CAAE;EACrC,CAAC,GACD,IAAI,iBAAc;AAChB,QAAI,eAAe,OAAO,gBAAgB,UAAU;AAClD,aAAO,YAAY,OAAO,OAAO,MAAM;IACzC;AACA,WAAO;EACT,CAAC,CAAC;EAGJ,cAAA;EAAgB;EAEhB,MAAM,OAAe,UAAgB;AACnC,WAAO,KAAK,2BAA2B,KAAK,MAAM,OAAO,QAAQ,CAAC;EACpE;EAEM,OAAO,SAA2C;;AACtD,UAAI;AACF,cAAM,QAAQ,KAAK,IAAI;AAEvB,cAAM,QAAQ,SAAS,SAAS;AAChC,cAAM,OAAO,SAAS,QAAQ;AAE9B,aAAK,kBAAkB,QAAQ,OAAO,IAAI;AAC1C,aAAK,OAAO,SAAS,CAAC,cAAc,CAAC;MAEvC,SAAS,KAAK;AACZ,gBAAQ,MAAM,8BAA2B,GAAG;AAC5C,aAAK,kBAAkB,MAAM,SAAS,mEAA6D;AACnG,cAAM;MACR;IACF;;EAEA,kBAAe;AACb,WAAO,KAAK,aAAa,KACvB,IAAI,CAAAA,UAAQ,CAAC,CAACA,KAAI,CAAC;EAEvB;EAEM,eAAe,iBAAyB,aAAmB;;AAC/D,YAAMA,QAAoB,KAAK,KAAK;AAEpC,UAAI,CAACA,SAAQ,CAACA,MAAK,OAAO;AACxB,cAAM,IAAI,MAAM,8DAA2D;MAC7E;AAEA,UAAI;AACF,cAAM,aAAa,kBAAkB,WAAWA,MAAK,OAAO,eAAe;AAC3E,cAAM,6BAA6BA,OAAM,UAAU;AACnD,cAAM,eAAeA,OAAM,WAAW;AACtC,gBAAQ,IAAI,qDAAkD;AAC9D,eAAO;MAET,SAAS,OAAO;AACd,gBAAQ,MAAM,mDAAgD,KAAK;AACnE,cAAM;MACR;IACF;;;qCArEW,cAAW;EAAA;4EAAX,cAAW,SAAX,aAAW,WAAA,YADE,OAAM,CAAA;;;sEACnB,aAAW,CAAA;UADvB;WAAW,EAAE,YAAY,OAAM,CAAE;;;",
  "names": ["user"]
}
